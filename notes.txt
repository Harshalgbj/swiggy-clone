npm -- it manage the package .
       it take of version in package.json

*
 1).npm init         => for package.json
*

 package.json - also know as dependency

parcel
*
 2). npm install -D parcel   (-D => dependency)   => for package.lock.json
*
"parcel" : "^2.8.3"
caret (^) ---> it update the minor version (upgrade) only ie - "^2.8.5" 

"parcel" : "~2.8.3"  
tilde(~)  ---> it update the major version .

CARET is recommended.

difference betn  --  package.json  && package-lock.json

package.json --- it keep approx version 

package-lock.json ----its track of the exact version of that dependency or package
                   
if u have package.json  &&  u have package-lock.json 
then u dont have to worry abut node_modules 
as u can regenerate.
*
    npm install 
         |
     it recreates node_modules again    
*
 integrity ---> 

node-Modules --> contain all the actual data of packages
                  transitive dependency

(
npm install
npm install parcel)

*  to host apps ---

   npx parcel index.html
*
npx --- executing the package

 script scr (url) for react is not recommended 
 
 npm install react     ==> to install the react
 
 npm install react-dom   ==> for  react-dom 


# parcel works - (Manager of all library)
  Dev Build
  Local Server 
  HMR - hot module replacement  (refreshing automatically in browser)
   |- file watching algorithm - written in c++
  caching - faster builds  (reduce the time its in { parcel-cache}  ie -  Built in 1.04s)
  IMAGE Optimization 
  minification of files
  bundling files 
  compressing files
  consistent hashing  => ?
  code splitting 
  differential buldling  (to support old browser)
  diagnostic 
  error handling (detail of error)
  https
  different dev and prod bundle

-----------------------------------------------

 # command 
*
 npx parcel build index.html
*
it give error in output --
 "description": "its
  > 5 | in": "script.js",    
  >   |      ^^^^^^^^^^^ Did you mean "script.html"

so in package.json --

{
 1. "name": "igniting-apps-2",
 2. "version": "1.0.0",
 3. "description": "its igniting apps",
 4. {  "main": "script.js", }  -----------> REMOVE THIS LINE
 5."scripts": {
    "test": "jest"
  },

WHEN we delete line 4 we get output as--

dist\index.html                482 B    15.70s     
dist\index.ad248605.css         84 B    10.38s     
dist\index.eb28d9ef.js     140.34 KB    15.29s     

this files are PRODUCT READY files TO serve USERS

parcel-cache / dist / node_modules
  can be regenerate by following command
*
 npx parcel index.html
*

as it can regenerate SO NO need to push it in GITHUB 
so PUT in to .Gitignore folder

----------
browser-list (to tell computer in which browers to support)

IN package.json---write =>
  "browserslist": [
    "last 10 Chrome version",
    "last 10 Firefox version"
          or
        "last 2 version",    
  ]


meaning ---

 npx parcel index.html  => executing package in source file  => deveploment Build
 types --- production build && deveploment build

=> we can create to replace  the ABOVE comment
*
npm run  start  || npm start   ==> for production 
*
npm run  build   ==> for deveploment   
* 

in package.json we have wrote scripts for the command
ie--    "scripts": {
    "start": "parcel index.html",
    "build": "parcel build index.html",
    "test": "jest"
  },


----------------------------------------------------
 JXS   ----> its not HTML in JS 
             ITS html-likes or XML-like syntax
it understands  ES6   ie Ecmascript

// (this code is converted before it reaches JS Engine) --done by PARCEL && BABEL

BABEL --- its transpiler (js compiller)

JSX ==> CONVERTED to react.createElement =>  reactElement-js object ==> HtmlElement(render)

 # Attributes  ---> to JSX use camelcase ie  harshalGangurde
ie -- className=""

valid code  ---- in single line|
  const jskHeading = <h1 className="head">nameste JSX</h1>;

---in multiple line  use ()
( const jskHeading = <h1 className="head">
nameste JSX</h1>  ); 

------------------------------------------
// React component
 types --- class based  (this is Old)
           functional based   (this is new )

syntax type ------

const HeadingComponent = () => {
  return <h1>this is Functional component</h1>;
};

const HeadingComponent = () => (
   <h1>this is Functional component</h1>;
);


if we want two component in div then

#  its Component composition
div id="root"
  <Title/>    ====>   just write this syntax in the function 
  div class="head" 

{ }  ==> u can us to render  js in div 
ie {numbers ,element , 300+200}

JSX TAKE care if api.data is injected in ur div browser 
if its malicious attact it protect browers
 
<div id = parent>   in console this div will be seen 
  <div></div>
  <div></div>
  <p></p>
</div>;

# React Fragment

<React.Fragment>    in console this Fragment will not be seen
 <div></div>
  <div></div>
  <p></p>
</React.Fragment>

   OR 

<>  
 <div></div>
  <div></div>
  <p></p>
</>



-----------------------------------------------------------------------------

  #  Making Project Food apps

HEADER  --> LOGO 
            NAV BAR ---> HOME | ABOUT

BODY   --> SEARCH BAR 
           CARD CONTAINER ---> CARDS ---
                                       

FOOTER ---> COPYWRITE 
          CONTACT INFO 
          ABOUT US



 const stylecard ={
  backgrounColor = "#f0f0f0"
 }

Style = {stylecard }


props is property 

const CardContainer = (props) => {

    or 
const CardContainer = ({resName ,crusine}) => {    

 
 # conflict driven UI

optional chaining    => (?) 
     const { name,rating,crusines} = resdata?.data
   
   when u use .map() all use   -- keys  



 REACT hooks ----
 its a  normal js utility function which is written in react
 
 whenever state Variable is updated react rerender its component

1. usestate () - superpowerful State Variable 
                 
 useEffect()


react uses reconsoliation algorithm (react fiber) 
--> virtual DOM -- representation of actual DOM 
                 its normal js nested object  

div algorithm --- tries to find differnce betn old and new dom 
   
react is doing effecient Dom manupulation 


* config UI


useEffect----


? shimmer effect--
 
 props------> router={appRouter} 

types of router --->
 client side routing 
 serve side routing

 Outlet -- all children go in this



useParams  --- to read URL

class component ------> 
  render Method ---- Imp


 in make my trip (for system design interview)
--->
  chunking
  code splitting 
  dynamic Import 
  on demand loading
  lazy loading

const Instamart = lazy(() => import("./components/instamart"));
    <Suspense>
     <Instamart />
    </Suspense>


  because on rendering instamart  it take 27ms 
  before that error comes ,but when we refresh it again 
  it will show the PAGE

  to handle THIS ISSUE use   <Suspense>

 import("./components/instamart")); ---> its a PROMISE



TO study Now --
 
1) Talwin css -->>
  - CSS on same file
  - reusability 
  - less bundle size
  flexible UI 

css--
 // w-[200px]

Pros---
 code is less 
 no duplicate css
 faster deveploment
 easy to debug

 Cons--
 high learning 
 too much classNames

 
states and Props use Data 
there is UI And Data Layer

state -- local variable




props  -- value pass fr one to another component 
       
// profiling in inspect
it record all render like clickin on homw and then to about

       
// useContext------
to accesess data  to all the apps 

Ways----
1)import UserContext from "../utils/UserContext";

  <UserContext.Consumer>
            {({ user }) => <h4 className="font-bold">{user.name}</h4>}
          </UserContext.Consumer>

2)import { useContext } from "react";
import UserContext from "../utils/UserContext";
 
   const { user } = useContext(UserContext);

       <h4>This side is Developed by {user.name}</h4>

to modify user DATA --------->>

 const AppLayout = () => {
  const [user, setUser] = useState({
    name: "Sarvesh Bro",
    email: "xyz@gmail.com",
  });
  return (
    <UserContext.Provider value={{ user: user }}>
      <Header />
      <Outlet />
      <Footer />
    </UserContext.Provider>
  );
};

 diffn  bundler and react ?
 *****

 redux-------->

 if we click + button it dispatches an action which call the reducer function
 which updated slice of the redux store
--> seclector(to read data .its a HOOK ) --> will update my card 
*****
to install redux
npm i  @reduxjs/toolkit
  +
 npm i  react-redux



to install Tesing library

 npm i --save-dev @testing-library/react
    +
 npm i -D jest
   +
   npx jest --init   

   then question is asked  ----->
                                                  
PS D:\React\React Course\apr3\igniting apps-2> npx jest --init

The following questions will help Jest to create a suitable configuration for your project

âˆš Would you like to use Typescript for the configuration file? ... no
âˆš Choose the test environment that will be used for testing Â» jsdom (browser-like)
âˆš Do you want Jest to add coverage reports? ... yes      
âˆš Which provider should be used to instrument code for coverage? Â» babel
âˆš Automatically clear mock calls, instances, contexts and results before every test? ... yes

ðŸ“  Configuration file created at D:\React\React Course\apr3\igniting apps-2\jest.config.js
 
--------------
    npm run test

> igniting-apps-2@1.0.0 test
> jest

â— Validation Error:

  Test environment jest-environment-jsdom cannot be found. Make sure the testEnvironment configuration option points to an existing node module.

  Configuration Documentation:
  https://jestjs.io/docs/configuration


As of Jest 28 "jest-environment-jsdom" is no longer shipped by default, make sure to install it separately.    
 
 to fix this use --->
 
    npm i -D jest-environment-jsdom

 now Config our babel--->

 npm i --save-dev babel-jest @babel/core @babel/preset-env


.toBeInTheDocument(); 
--->
 npm i -D @testing-library/jest-dom


 ------------------------------------

? headless browers
? selenium testing 
 manual testing 
 unit testing
 integrating

JEST ===>
 its js testing framwork 






